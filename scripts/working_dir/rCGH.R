##### this is the guide to rCGH package. use this with the pdf in docs


## set working directory
working_dir = "C:/Users/e.bordron/Desktop/CGH-scoring/M2_internship_Bergonie/scripts/working_dir"
setwd(working_dir)
## open working directory in Files tab
rstudioapi::filesPaneNavigate(working_dir)
#loading libraries
library(rCGH)

## define paths
sampleName = "5-LD"
# sampleName = "6-VJ"
# sampleName = "7-DG"
pathToTxt = paste0("C:/Users/e.bordron/Desktop/CGH-scoring/data/working_data/from_laetitia/all_probeset/",sampleName,".probeset.txt")
outputFolder = paste0("C:/Users/e.bordron/Desktop/CGH-scoring/M2_internship_Bergonie/results/rCGH/",sampleName)
outputFolder_plots = file.path(outputFolder, "plots")


## ----style-knitr, eval=TRUE, echo=FALSE, results="asis"--------------------
BiocStyle::latex()
## ----setup, include=FALSE-----------------------------------------------------
options(width = 80)
require(knitr)
opts_chunk$set(dev='png', prompt=TRUE, comment=NA, tidy=FALSE)

## ----Functions -----------------------------------------------------
removePointsForQuickPlotting = function(cghDf, pointsToKeep=10) {
    # if pointsToKeep=5, we keep 1 value out of 5.
    cghDfFiltered = dplyr::slice(cghDf, seq(1,length(cghDf[,1]),pointsToKeep))
    return(cghDfFiltered)
}

getNewPos = function(cghDf, lengthOfChrs) {
    currChr = as.numeric(cghDf["ChrNum"])
    if (currChr!=1){
        pos0CurrChr = sum(lengthOfChrs[1:currChr-1])
    } else {
        pos0CurrChr=0
    }
    newPos = pos0CurrChr + as.numeric(cghDf["ChrStart"])
    return(newPos)
}




## ----readFiles, warning=FALSE, message=FALSE----------------------------------
filePath <- system.file("extdata", "Affy_cytoScan.cyhd.CN5.CNCHP.txt.bz2", package = "rCGH")
example_cgh <- readAffyCytoScan(filePath, sampleName = "CSc-Example",
                        labName = "myLab")
# filePath <- system.file("extdata", "oncoscan.tsv.bz2", package = "rCGH") # template file generated by APT program to produce copy number.
customFilePath = pathToTxt
cgh = rCGH::readAffyOncoScan(customFilePath)
cgh@info["sampleName"] = sampleName
# create a column "absolute position" for better plots
lengthOfChrs = c(247249719, 242951149, 199501827, 191273063, 180857866, 170899992, 158821424, 146274826, 140273252, 135374737, 134452384, 132349534, 114142980, 106368585, 100338915, 88827254, 78774742, 76117153, 63811651, 62435964, 46944323, 49691432, 154913754, 57772954)
cgh@cnSet$absPos = apply(cgh@cnSet, 1, getNewPos, lengthOfChrs)

## ----cgh, warning=FALSE, message=FALSE----------------------------------------
cgh

## ----addInfo------------------------------------------------------------------
setInfo(cgh, "item1") <- 35
setInfo(cgh, "item2") <- TRUE
setInfo(cgh, "item3") <- "someComment"

## ----getInfo------------------------------------------------------------------
getInfo(cgh)
getInfo(cgh, c("item1", "item3"))

## ----adjustSignal-------------------------------------------------------------
cghAdj <- adjustSignal(cgh, nCores=6, suppOutliers=TRUE)

### see difference between and after adjusting data
adj = removePointsForQuickPlotting(cghAdj@cnSet)
raw = removePointsForQuickPlotting(cgh@cnSet)
plot(y=raw$Log2Ratio..5.LD.OSCHP., x=raw$absPos, pch=20, main="Raw data", cex=0.01, xlab="Genomic position (bp)", ylab="Log Ratio", ylim=c(-6,2))
plot(y=adj$Log2Ratio, x=adj$absPos, pch=20, main="Adjusted data", cex=0.01, xlab="Genomic position (bp)", ylab="Log Ratio", ylim=c(-6,2))


## ----SegmentCGH---------------------------------------------------------------
cghSeg <- segmentCGH(cghAdj, nCores=6)
segDf = cghSeg@cnSet
segDf = removePointsForQuickPlotting(segDf)
plot(y=segDf$Segm , x=segDf$absPos, pch=20, main=paste0(sampleName," Segmented data"), cex=0.01, xlab="Genomic position (bp)", ylab="Log Ratio", ylim=c(-6,2))
segTable <- getSegTable(cghSeg)

## ----segTable-----------------------------------------------------------------
head(segTable)

## ----EMnormalize--------------------------------------------------------------
cghNorm <- EMnormalize(cghSeg, peakThresh=2)
### plot to compare with seg before this 2nd normalisation
segDfNorm = cghNorm@cnSet
segDfNorm = removePointsForQuickPlotting(segDfNorm)
plot(y=segDfNorm$Segm , x=segDfNorm$absPos, pch=20, main=paste0(sampleName," Normalized segmented data"), cex=0.01, xlab="Genomic position (bp)", ylab="Log Ratio", ylim=c(-6,2))

## ----plotDensity, fig.width=7, fig.height=5, fig.show='hide'------------------
plotDensity(cghNorm)

## ----byGeneTable--------------------------------------------------------------
geneTable <- byGeneTable(segTable)
head(geneTable, n=3)

## ----byGeneTable2-------------------------------------------------------------
byGeneTable(segTable, "erbb2", genome = "hg19")[,1:6]
byGeneTable(segTable, "erbb2", genome = "hg18")[,1:6]

## ----getParams----------------------------------------------------------------
getParam(cghNorm)[1:3]

## ----getProfile, fig.width=7.7, fig.height=9.5, fig.show='hide'---------------
multiplot(cghNorm, symbol = c("egfr", "erbb2"))

## ----recenter, fig.width=7.5, fig.height=4, fig.show='hide'-------------------
# Recentering on peak #2
recenter(cghNorm) <- 2
plotProfile(cghNorm, symbol = c("egfr", "erbb2"))

### also plotting LOH
plotLOH(cghNorm)


## ----view, eval=FALSE, echo=TRUE----------------------------------------------
#  view(cghNorm)

## ----exampleFiles-------------------------------------------------------------
list.files(system.file("extdata", package = "rCGH"))

## ----session------------------------------------------------------------------
sessionInfo()






















###################################################################### methods

function (object, Scale = TRUE, Cy = TRUE, GC = TRUE, Ref = "cy3", 
          suppOutliers = TRUE, nCores = NULL, verbose = TRUE) 
{
    if (!.validrCGHObject(object)) 
        return(NULL)
    cnSet <- getCNset(object)
    if (!inherits(object, "rCGH-Agilent")) {
        Cy <- FALSE
        GC <- FALSE
    }
    if (Cy) {
        if (verbose) {
            message("Recall you are using ", Ref, " as reference.")
            message("Cy effect adjustment...")
        }
        cnSet <- .CyAdjust(cnSet, Ref)
    }
    if (GC) {
        if (verbose) 
            message("GC% adjustment...")
        cnSet <- .GCadjust(cnSet)
    }
    object@param$CyAdjusted = Cy
    object@param$GCAdjusted = GC
    object@param$dLRs <- .dlrs(cnSet$Log2Ratio)
    object@param$MAD <- .MAD(cnSet$Log2Ratio)
    if (verbose) {
        message("Log2Ratios QCs:")
        message("\tdLRs: ", round(object@param$dLRs, 3))
        message("\tMAD: ", round(object@param$MAD, 3))
        message()
    }
    if (Scale) {
        if (verbose) 
            message("Scaling...")
        cnSet$Log2Ratio <- scale(cnSet$Log2Ratio, center = FALSE)
        cnSet$Log2Ratio <- cnSet$Log2Ratio * 1.2
    }
    nCores <- .setCores(nCores, verbose)
    if (suppOutliers) {
        if (verbose) 
            message("Signal filtering...")
        L2R <- cnSet$Log2Ratio
        Chr <- cnSet$ChrNum
        S <- NA
        cnSet$Log2Ratio <- .modelSignal(L2R, Chr, G = 1:5, method = "lr", 
                                        alpha = 2000, S, nCores, verbose)
    }
    if ("Allele.Difference" %in% colnames(cnSet)) {
        if (!all(is.na(cnSet$Allele.Difference))) {
            if (verbose) 
                message("Modeling allelic Difference...")
            signal <- cnSet$Allele.Difference
            chr <- cnSet$ChrNum
            S <- ifelse(inherits(object, "rCGH-oncoScan"), 
                        0.05, 0.04)
            modelAllDif <- .modelSignal(signal, chr, G = 2:5, 
                                        method = "loh", alpha = 2500, S, nCores, 
                                        verbose)
            cnSet$modelAllDif <- modelAllDif
        }
    }
    object@cnSet <- cnSet
    return(object)
}

############################################################### methods


 = function (object, Smooth = TRUE, UndoSD = NULL, minLen = 10, 
          nCores = NULL, verbose = TRUE) 
{
    if (!.validrCGHObject(object)) 
        return(NULL)
    ploidy <- as.numeric(getInfo(object, "ploidy"))
    cnSet <- getCNset(object)
    cnSet <- cnSet[order(cnSet$ChrNum, cnSet$ChrStart), ]
    params <- getParam(object)
    params$minSegLen <- minLen
    if (Smooth) {
        mad <- .getMAD(object)
        params$ksmooth <- floor(150 * mad) * 2 + 1
    }
    if (is.null(UndoSD)) {
        mad <- .getMAD(object)
        alpha <- 0.5
        if (inherits(object, "rCGH-Illumina")) {
            alpha <- 0.95
        }
        if (inherits(object, "rCGH-oncoScan")) {
            alpha <- 0.3
        }
        params$UndoSD <- alpha * mad^(1/2)
    }
    else {
        params$UndoSD <- UndoSD
    }
    L2R <- cnSet$Log2Ratio
    Chr <- cnSet$ChrNum
    Pos <- cnSet$ChrStart
    sampleName <- getInfo(object, "sampleName")
    if (is.na(sampleName)) {
        sampleName <- "sample_x"
    }
    nCores <- .setCores(nCores)
    if (verbose) {
        usd <- format(params$UndoSD, digits = 3)
        message("Computing LRR segmentation using UndoSD: ", 
                usd)
    }
    segTable <- .computeSegmentation(L2R, Chr, Pos, sampleName, 
                                     params, nCores)
    if (!is.null(minLen) && minLen < 0) {
        message("'minLen', the minimal segment length can't be < 0")
        minLen <- NULL
    }
    if (!is.null(minLen)) {
        if (verbose) 
            message("Merging segments shorter than ", minLen, 
                    "Kb.")
        segTable <- .smoothSeg(segTable, minLen)
    }
    segTable <- .computeMedSegm(segTable, L2R)
    segTable <- .mergeLevels(segTable)
    segTable <- .estimateCopy(segTable, ploidy)
    probeValues <- .probeSegValue(segTable)
    if (verbose) 
        message("Number of segments: ", nrow(segTable))
    params$nSegment <- nrow(segTable)
    object@param <- params
    object@segTable <- segTable
    object@cnSet <- cbind.data.frame(cnSet, Segm = probeValues)
    return(object)
}










## conclusion of this: I don't know how CN are estimated during segmentation phase. It is made using simple math, Running it with our samples should tell whether it is interesting or not.

.estimateCopy = function (st, ploidy, expect = log2(seq(1, 60)/2)) 
{
    P <- lapply(1:nrow(st), function(ii) {
        mi <- st$seg.med[ii] #seg.med = segment median
        if (mi > 5) 
            return(c(rep(0, length(expect) - 1), 1))
        si <- st$probes.Sd[ii]
        p <- sapply(expect, function(e) {
            dnorm(mi, e, si)
        })
        return(p)
    })
    #P contains a distribution: either a dnorm or a vector : c(0,0,0,0,0...0,0,0,1) (30 values total)
    ratio <- sapply(P, function(p) {
        .estimateRatio(p, expect)
    })
    copies <- ifelse(ratio == 0, 0, ifelse(ratio > 0, 2 * ratio, 
        -1/ratio))
    st$estimCopy <- copies + (ploidy - 2)
    return(st)
}


.estimateRatio = function (p, expect) 
{
    if (max(p, na.rm = TRUE) < 0.001) 
        return(0)
    return(2^expect[which.max(p)])
}